---
title: Elixir Brasil 2019 - Segundo dia
description: "O segundo dia de #ElixirBrasil foi t√£o impressionante quanto o primeiro - e eu estava l√° tamb√©m!"
date: "2019-06-16T20:00:00.000Z"
cover: ./amanda.jpg
---

<p>
    <a href="https://2019.elixirbrasil.com/" rel="nofollow" class="image-link" title="Elixir Brasil 2019">
        <img src="./elixir_brasil_logo.svg" alt="Elixir Brasil 2019" style="width: 413px; height: 164px">
    </a>
</p>

No post anterior, falei sobre o [primeiro dia do evento](/2019-05-30-elixir-brasil-2019-primeiro-dia/). Hoje trago para voc√™s o segundo dia - que foi t√£o impressionante quanto o primeiro. Foi na mesma pegada do dia anterior, com dois keynotes e duas trilhas paralelas. √â imposs√≠vel estar em dois lugares ao mesmo tempo, sen√£o tinha visto todas as talks. Foi o sentimento da galera do trampo que foi comigo tamb√©m, de ficarmos indecisos sobre o que assistir visto a qualidade das talks e temas escolhidos.

---

## Li√ß√µes aprendidas em um projeto Elixir / OTP - [Amanda Sposito](https://www.linkedin.com/in/amandasposito/)

Infelizmente, cheguei ~~muito~~ atrasado no evento e perdi o keynote da Amanda quase inteiro. Consegui ver o finalzinho com algumas dicas, que coloco aqui. Tentarei n√£o cometer esse vacilo da pr√≥xima vez, principalmente com uma talk que queria tanto ver üò¢

Quando cheguei, ela estava citando o artigo [Unit Tests in Elixir - Part 2](http://devonestes.herokuapp.com/unit-tests-in-elixir-part-2) do Devon C. Estes, por√©m n√£o peguei o contexto do que ela estava falando. Tamb√©m recomendou ver o [SORTID Elixir](https://www.youtube.com/watch?v=eldYot7uxUc), uma talk da Georgina McFadyen sobre os princ√≠pios `SOLID`, mas voltados para programa√ß√£o funcional e Elixir.

Em seguida, definiu que [Contexts](https://hexdocs.pm/phoenix/contexts.html), do Phoenix, definem limites entre diferentes m√≥dulos da aplica√ß√£o - n√£o tem mais aquele padr√£o `MVC`. Por√©m, esses contextos podem ficar maiores do que deveriam com o passar do tempo e com a intera√ß√£o entre eles. Uma dica ent√£o √© evitar manter c√≥digo ortogonal ao contexto, no contexto. Al√©m disso, mantenha *queries* pr√≥ximas ao seu *schema*. Uma exce√ß√£o para essa regra, segundo a Amanda, s√£o de *queries* que lidam com mais de um *schema*. Tamb√©m recomendou o outro post do Devon, [A Proposal for Some New Rules for Phoenix Contexts](http://devonestes.herokuapp.com/a-proposal-for-context-rules).

!["Mantenha queries pr√≥ximas de seu schema" - Amanda Sposito.](./amanda.jpg)

Sobre **Umbrella Projects**, a Amanda explicou que √© uma maneira de organizar seu c√≥digo, que vira tipo um monolito organizado. √â necess√°rio ter cuidado com depend√™ncias circulares, quando um app acessa o outro app que por sua vez acessa de novo o primeiro - enfim, voc√™s entenderam.

Essas foram as dicas que consegui pegar da talk. Os slides est√£o no [SpeakerDeck](https://speakerdeck.com/amandasposito/aprendizados-de-um-projeto-elixir-otp) e podem trazer mais insights sobre o que ela passou.

## Domain-Driven Design with Contexts - [Adam Tew](https://twitter.com/adamjtew)

Na trilha avan√ßada, come√ßamos com a talk do Adam, que trabalha na [Podium](https://www.podium.com/), e veio at√© o Brasil pra falar com a gente sobre _Domain-Driven Design_ (DDD), um tema que independe de uma linguagem espec√≠fica mas que casa muito bem com Elixir.

### Modelagem
O **DDD** √© primariamente utilizado para aplica√ß√µes maiores e precisa de muita pondera√ß√£o para modelar. Tem o objetivo de descobrir o que √© o dom√≠nio. O [livro sobre DDD do Eric Evans](https://www.amazon.com.br/dp/B00794TAUG/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1) √© o que voc√™ pode ler para aprender sobre os conceitos do DDD.

No DDD, voc√™ precisa de um **dom√≠nio** para modelar. Um dom√≠nio √© o problema que o seu cliente, ou a sua empresa, quer resolver. Voc√™ precisa de **especialistas de dom√≠nio** que entendam muito sobre o problema proposto. Use **mapeamento de contexto** para descoberta, coloque todos os envolvidos numa sala e pe√ßa para os mesmos escreverem tudo sobre o dom√≠nio em *post-its* e coloque numa parede, para que voc√™s definam as **entidades** (substantivos) e os **eventos** (verbos).

![Adam Tew mapeando entidades e eventos.](./adam.jpg)

Agrupe todas as entidades que fa√ßam sentido. Seu **core domain** (dom√≠nio principal) √© essencialmente o que √© realmente importante para o neg√≥cio. Voc√™ tem tamb√©m **support domains** (dom√≠nios de suporte), que apoiam o *core domain* a atingir seu objetivo.

![Dom√≠nios de suporte no DDD.](./ddd_support_domains.jpg)

Outras maneiras de mapear seus dom√≠nios √© atrav√©s de *Domain Storytelling*, que tenta contar uma hist√≥ria sobre os atores e as a√ß√µes entre eles, ou de *Event Storming*. √â importante sempre utilizar uma **linguagem ub√≠qua** entre todos do time. Escreva em algum lugar uma lista de todas as palavras comuns utilizadas.

### Modulariza√ß√£o
Ap√≥s agrupar os dom√≠nios, √© hora de fazer algo em rela√ß√£o a isso. Numa arquitetura de camadas (*Layered Architecture*), temos a `UserInterface` como ponto de entrada, se comunicando com as camadas abaixo: `Application`, `Domain` e `Infrastructure`. De `Application`, a comunica√ß√£o √© com `Domain` e `Infrastructure`. E assim por diante. As depend√™ncias fluem para as camadas abaixo.

![Arquitetura de Camadas de uma aplica√ß√£o feita com DDD.](./ddd_layered_architecture.jpg)

Um *bounded context* est√° tipicamente em um alto n√≠vel de granularidade e define uma √°rea completa de funcionalidade dentro do seu sistema. Voc√™ deve abstrair o que provavelmente ir√° mudar no futuro, que √© a l√≥gica de neg√≥cio.

Para gerar um contexto, podemos testar os [geradores de c√≥digo do Phoenix](https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.Html.html#content):

```bash
mix phx.gen.html Menu MenuItem menu_items name:string:unique quantity:integer
```

Um contexto deve dizer a **inten√ß√£o** do que voc√™ quer fazer e n√£o **como** voc√™ fez isso. E isso √© algo muito dif√≠cil de se fazer segundo o Adam.

#### Assimilando Conhecimento
Prefira ciclos de desenvolvimento √°gil. Voc√™ vai descobrir as coisas depois do que voc√™ acha que deveria descobrir. Junte os dados que devam estar juntos. Um **Aggregate** representa esses dados que deveriam estar juntos. O **Aggregate root** √© o elemento principal. Prefira passar os **aggregates** pelo sistema, tendo todos os dados que voc√™ precisa diretamente.

#### Como compartilhar entre os diferentes contextos
Tem uma palestra do Andrew Hao, [Event-driven messaging](https://www.youtube.com/watch?v=5MBGDM8xSQg) que fala sobre como fazer mensageria em um sistema orientado a eventos.

Use os **eventos** do **mapa de contextos** com pub/sub. Crie um `EventBus` e dentro do contexto crie um m√≥dulo `EventHandler`, que vai receber eventos do `EventBus`.
Esse conceito √© conhecido no DDD como camada **anti-corrup√ß√£o**, que n√£o polui um contexto com dados de outro contexto, se comunicando atrav√©s de mensagens.

### Preocupa√ß√µes
O Adam exp√¥s suas preocupa√ß√µes sobre o DDD, come√ßando com o fato de que h√° toneladas de teoria sobre o tema, representando muito pra absorver e pensar sobre durante o aprendizado. Provavelmente, utilize DDD somente para grandes bases de c√≥digos - e para essas grande bases, implemente em fases, pe√ßa por pe√ßa. Pode ser dif√≠cil de se aprender tamb√©m pelo fato de os livros serem mais voltados para OO, precisando pensar em como ficaria com programa√ß√£o funcional.

### Conclus√µes
Priorize a **descoberta dos dom√≠nios**. Abstraia no sistema o que ir√° mudar no **neg√≥cio**. Escute os **especialistas de dom√≠nio**. Sempre consulte o **mapa de contextos**. O Adam tamb√©m citou o livro [Functional and reactive domain modeling](https://www.manning.com/books/functional-and-reactive-domain-modeling) como uma refer√™ncia da sua talk.


[Confira os slides da talk do Adam.](https://docs.google.com/presentation/d/1ano0faAXjj4GMw6bJDLeI1-RtX_DlDLLQAkjXnAEGdY/edit)


## A Divina Com√©dia de um C√≥digo Legado: indo do Inferno ao Para√≠so com Elixir - [Juliana Helena](https://twitter.com/julianahelenaa5)


![A Divina Com√©dia de um C√≥digo Legado: indo do Inferno ao Para√≠so com Elixir - Juliana Helena (foto original do <a title="Twitter - Juliana Helena" href="https://twitter.com/julianahelenaa5/status/1132707780132069377" rel="nofollow">twitter dela</a>).](./juliana.jpg)

A Juliana veio de Belo Horizonte para nos contar do case que ela participou no trabalho, em um projeto que tinha c√≥digo legado.

Assim, foi atr√°s de encontrar formas de se trabalhar com esse c√≥digo. Citou o livro [Working Effectively with Legacy Code](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052) (Trabalhando de forma efetiva com c√≥digo legado). O autor define c√≥digo legado simplesmente como **c√≥digo sem testes**.
E diz que **c√≥digo sem testes √© c√≥digo ruim**. Com testes conseguimos ter confian√ßa de mudar o comportamento do nosso c√≥digo. Sem testes n√£o sabemos se nosso c√≥digo est√° evoluindo ou regredindo com o passar do tempo.

> C√≥digo legado **tamb√©m** √© o c√≥digo que voc√™ acabou de escrever.

√â importante manter o **respeito** e entender o **contexto** do c√≥digo duvidoso que voc√™ encontra, n√£o d√° pra saber porque aquele c√≥digo est√° daquela forma.
Ok, mas voc√™ recebeu o problema: e agora, como lidar? A primeira coisa que voc√™ pode pensar √©: vou reescrever tudo! Voc√™ tem duas op√ß√µes: **refazer** ou **refatorar**, ambas com fatores a se considerar:

- **Refazer**: custo, prazo, manter o legado funcionando em paralelo
- **Refatorar**: come√ßar com pequenas mudan√ßas, ter qualidade em todo novo c√≥digo e fazer um planejamento para pagar a d√≠vida t√©cnica frequentemente.

Voc√™ pode tentar convencer a equipe, evangelizando sobre qualidade de c√≥digo, explicando sobre escalabilidade e menor custo de corre√ß√£o. Se tudo n√£o funcionar: comece pequeno, mostre seus resultados e, em √∫ltimo caso, se n√£o tiver jeito, mude de emprego.

Falando sobre o case, a Juliana nos explicou como era l√°. Assim vamos para a parte 1, **o Inferno**.

### Inferno
Existiam equipes em S√£o Paulo e Belo Horizonte. V√°rias aplica√ß√µes antigas e dif√≠ceis de escalar. N√£o havia cultura focada em qualidade de c√≥digo. Existiam falhas de comunica√ß√£o e falta de processos (para apagar os inc√™ndios por exemplo). O conhecimento era centralizado em algumas pessoas e n√£o havia muita documenta√ß√£o.

Em resumo:
- Era uma rede de aplica√ß√µes dependentes e sem testes ou informa√ß√µes precisas sobre o funcionamento.
- N√£o havia **seguran√ßa** para realizar altera√ß√µes - o que era um pouco suavizado pelo conhecimento da galera.

Por√©m chegou uma not√≠cia de reestrutura√ß√£o das equipes na empresa e todos os sistemas legados ficaram sob responsabilidade das equipes de BH, que n√£o tinham conhecimento de tudo, j√° que ele era centralizado em outras equipes. As pessoas com maior conhecimento acabaram indo para outros times. Ela deu algumas sugest√µes de leitura, como o livro j√° citado [Working Effectively with Legacy Code](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052), al√©m do [Refactoring](https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature/dp/0134757599) e o [Clean Code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship-ebook/dp/B001GSTOAM).

### Purgat√≥rio
Para fazer a migra√ß√£o, tr√™s **pilares** foram definidos, sendo eles: transferir conhecimento de c√≥digo n√£o documentado; conseguir manter o funcionamento das aplica√ß√µes e reestruturar os times.

Houve um processo **pr√© migra√ß√£o**, que envolveu a defini√ß√£o de uma **equipe de migra√ß√£o**, a divis√£o dos projetos entre as pessoas; a cria√ß√£o de documenta√ß√£o e aprendizado sobre projeto. Foi necess√°rio entender os processos: quando dava um problema, rodavam um script e tentavam aprender o que acontecia. Al√©m disso, haviam reuni√µes para compartilhamento de conhecimento e para esclarecimento de d√∫vidas.

Assim, com tudo definido, ocorreu o processo de migra√ß√£o. Em seguida, ocorreu o processo **p√≥s migra√ß√£o**, com a cria√ß√£o de *squads* e algumas pessoas ajudantes voltando para seus *squads* normais. Foi necess√°rio manter est√°vel o funcionamento dos legados e assim se deu o come√ßo do processo de reestrutura√ß√£o, com a cria√ß√£o de novas aplica√ß√µes.

#### Por que o Elixir?
Segundo o l√≠der t√©cnico da Juliana, a escolha do Elixir foi para resolver problemas de concorr√™ncia e tamb√©m por ser funcional. Al√©m disso, j√° existiam alguns cases de sucesso da empresa em Elixir e por isso tamb√©m j√° existia um background da equipe.

Assim nasceu o **AppPay**, com qualidade, testes, escal√°vel, desacoplado e seguindo boas pr√°ticas.

#### Pr√≥ximos passos
Evoluir novas aplica√ß√µes, manter os legados **est√°veis** com o m√≠nimo de interven√ß√£o poss√≠vel, at√© que a maior parte dos legados morra, tendo um processo bem estruturado, qualidade, c√≥digo escal√°veis e eles cheguem no:

### Para√≠so
Para se manter no Para√≠so, ela diz que √© muito importante manter uma boa **comunica√ß√£o**. Tamb√©m fazer **1x1 com o gestor/l√≠der t√©cnico** para ter feedbacks precisos e mentoria. Focar em **documenta√ß√£o** √© essencial, ela cita inclusive o exemplo do [Swagger](https://petstore.swagger.io/) para documentar APIs. Uma boa pr√°tica √© a de **code review** (com cuidado na comunica√ß√£o). √â preciso ter foco em **qualidade de c√≥digo**, com testes e usando inclusive *linters*. S√£o necess√°rios **processos bem definidos**, com cerim√¥nias bem feitas, tarefas bem escritas, prioridades estabelecidas e respeitadas. **Acessibilidade** √© algo legal de se pensar desde o in√≠cio, n√£o sendo necess√°rio esperar surgir uma demanda pra isso.

### Considera√ß√µes finais
N√£o existe bala de prata, depende do projeto e tipo de gest√£o. Tente criar uma cultura de foco em qualidade, que vai evoluindo junto com o time. **Incentive sua comunidade local**, com palestras, espa√ßo f√≠sico/coffee breaks, mentoria e open source. **Incentive mulheres, pessoas negras, pessoas LGBTQI+, pessoas trans e pessoas com  defici√™ncia** no seu time, empresa e comunidade. √â importante que as empresas/RHs invistam em forma√ß√£o e busca ativa. Tamb√©m √© muito importante deixar as pessoas falarem, respeitar o espa√ßo de fala de cada um.
A Juliana [criou um texto](https://bit.ly/culturadediversidade) sobre como criar uma cultura de diversidade em sua empresa, vale a pena ler!

Para conferir os slides da apresenta√ß√£o, [clique aqui](https://speakerdeck.com/julianahelena5/a-divina-comedia-de-um-codigo-legado-indo-do-inferno-ao-paraiso-com-elixir).


## Primeiros passos com Nerves - Elixir based IoT - [Donato Viana](https://twitter.com/donatoaz)

![Primeiros passos com Nerves - Elixir based IoT - Donato Viana.](./donato.jpg)

Resolvi voltar do almo√ßo e ir para a trilha iniciante, para ver a talk do Donato, que tive oportunidade de conhecer no p√≥s evento do dia anterior. Fiquei interessado para conhecer o Nerves, mesmo sem nunca ter mexido com o [IoT](https://pt.wikipedia.org/wiki/Internet_das_coisas). Ele come√ßa sua talk definindo que Linux embarcado significa que √© otimizado e customizado para dispositivos embarcados. Alguns aspectos importantes de dispositivos embarcados: temos recursos limitados (em certos aspectos), h√° um *overhead* de desenvolvimento - *cross compiling*, *flashing*, etc. e precisamos pensar em atualiza√ß√µes em campo, no dispositivo, que est√° distante de n√≥s.

### Nerves
√â uma plataforma, um framework, um conjunto de ferramentas e um *toolchain* para fazer Elixir Embarcado. Mas, com isso, surge a pergunta: "por que Elixir Embarcado?" - e a resposta √©: Por que n√£o? Foi pra isso que a BEAM foi criada, para telecomunica√ß√µes altamente dispon√≠veis. O mundo real √© concorrente: coisas acontecem ao mesmo tempo ou em algum tempo n√£o previs√≠vel.

![Como tudo se relaciona em uma aplica√ß√£o Nerves.](./app_nerves.jpg)

Um **toolchain** √© um conjunto de ferramentas para compilar para diversas arquiteturas. **Plataformas** s√£o imagens customizadas, feitas pela comunidade para rodar nos dispositivos. O Fluxo de desenvolvimento, basicamente √©: faz o c√≥digo, compila e empacota o firmware, em seguida o transfere para o dispositivo, testa, corrige bugs e repete.

Entre os pontos fortes est√£o o **boot r√°pido**, de segundos; o **tamanho reduzido** (menos de 100mb); a estrat√©gia de **update com imagem inteira**; a estrat√©gia de **fallback com parti√ß√µes A/B** - somente alterando a vers√£o caso funcione; a **robustez ante a perda de energia** (o sistema de arquivos √© somente leitura) e **atualiza√ß√µes OTA** (*Over The Air*, igual voc√™ provavelmente atualiza seu Android).

> "O Nerves est√° fazendo para desenvolvimento embarcado e Elixir o que o Rails fez pelo desenvolvimento web e pelo Ruby."
>
> Arto Bendiken

Em seguida o Donato fez um *live coding* mostrando rapidamente como √© a cara do framework e como desenvolver algo para o [Raspberry PI](https://www.raspberrypi.org/) dele - no caso, piscar um LED, que ele disse ser o "Hello World" do mundo IoT. Os v√≠deos da apresenta√ß√£o est√£o dispon√≠veis no YouTube:

1. [Elixir Nerves - blinky example](https://www.youtube.com/watch?v=PniEVXOYd3g)
2. [Elixir Nerves OTA using uploader script](https://www.youtube.com/watch?v=F-mYpVabptw)
3. [Elixir Nerves ssh and show log](https://www.youtube.com/watch?v=QM9rnAsl95A)

Em seguida, o Donato mostrou pra gente um projeto IoT incr√≠vel chamado [Farmbot](https://farm.bot/), vale a pena ver o [v√≠deo no YouTube](https://www.youtube.com/watch?v=uNkADHZStDE) ou conferir o site.

Os slides da talk est√£o dispon√≠veis no [SlideShare](https://www.slideshare.net/DonatoAzevedo/primeiros-passos-com-nerves-elixir-para-dispositivos-embarcados).


## Testando no mundo Elixir - [Rafael Rocha](https://twitter.com/RocRafael)

Quando come√ßamos uma est√≥ria de usu√°rio, vemos a descri√ß√£o, os crit√©rios de aceite e come√ßamos a desenvolver. Mas... estamos trazendo as especifica√ß√µes para o c√≥digo? E qu√£o confiante voc√™ fica com a sua entrega? Ent√£o, **por que testar**?

Segundo o Rafael, testar ajuda a ter **confian√ßa** sobre suas entregas, ajuda a **organizar** os pensamentos, mant√©m os **custos baixos** e traz mais **qualidade** para o produto.

### Tipos de teste

Um **Teste de Aceita√ß√£o** expressa um cen√°rio, √© de ponta a ponta, garante mais a qualidade externa e √© mais pr√≥ximo da camada de apresenta√ß√£o - por√©m √© lento. Um **Teste de Integra√ß√£o** fica entre os testes de aceita√ß√£o e os testes unit√°rios. Um **Teste Unit√°rio** testa o comportamento de uma √∫nica unidade do sistema.

![Rafael e a Pir√¢mide de Testes.](./rafael.jpg)

O Rafael trouxe um exemplo para exercitar testes, mostrando conceitos e implementa√ß√µes. Ele usou uma estrat√©gia de "cebola", de testar em camadas, de fora pra dentro. Para poder entender as camadas, voc√™ precisa fazer uma reflex√£o sobre quais elas s√£o, ajudando na compreens√£o do problema. Ele mostrou de forma bem r√°pida como seria o formato de cada um dos testes e o tipo de seguran√ßa que aquele teste traz. Ele tamb√©m ensinou um pouco sobre os **Dubl√™s** de teste, para evitar tocar sistemas externos.

Trouxe ainda o conceito de `Doctests`, explicando que √© uma ferramenta para garantir que a nossa documenta√ß√£o esteja v√°lida. Basicamente, voc√™ coloca no *docblock* um exemplo de como funcionaria aquela fun√ß√£o e pode rodar esse exemplo como c√≥digo, para ver se o comportamento da fun√ß√£o est√° correto.

O c√≥digo encontra-se [dispon√≠vel no GitHub](https://github.com/rafaelrochasilva/greenbox). Um outro recurso legal √© o post [Starting with Elixir, the Study Guide](http://blog.plataformatec.com.br/2018/11/starting-with-elixir-the-study-guide/), guia de estudos sobre Elixir escrito pelo pr√≥prio Rafael. [Confira os slides](https://speakerdeck.com/rafaelrochasilva/testando-no-mundo-elixir) que incluem o c√≥digo e os testes feitos de forma mais explicativa.

## Mantendo a Sanidade Testando Estado - [Andrew Rosa](https://twitter.com/_andrewhr)

De volta a trilha avan√ßada, tivemos a talk do Andrew, falando sobre como manter a sanidade testando estado com o conceito de **testes baseados em propriedades**. E para isso, ele utiliza a ferramenta [PropEr](https://jeffkreeftmeijer.com/mix-proper/) com seu c√≥digo Elixir.

Um simples teste pode ser:

```elixir
test "sorts a list" do
	assert Enum.sort([3, 1, 2]) == [1, 2, 3]
end
```

Esse √© um teste onde voc√™ informa a lista a ser ordenada, no caso `[3, 1, 2]` e o que esperar exatamente da ordena√ß√£o, `[1, 2, 3]`. J√°, em um **teste de entrada**, voc√™ n√£o define uma entrada espec√≠fica como o exemplo acima (`[3, 1, 2]`), mas pede algumas listas aleat√≥rias para testar o seu c√≥digo. Por exemplo, `[1]`, `[3, 1, 2, 9, 5]`, `[1, 1, 1, 0]`, `[1, 2]`, `[]`. Voc√™ tem alguns geradores que pode usar para gerar dados como esses para testar seu sistema. Para seu teste funcionar agora, √© necess√°rio mudar a l√≥gica que ele testa. Como n√£o sabemos qual lista vai vir, ao inv√©s de comparar com uma lista ordenada como antes, agora verificamos se todos os itens est√£o na ordem ap√≥s rodar a fun√ß√£o de sort. E assim, voc√™ roda os seus testes e verifica se a sua fun√ß√£o funciona como esperado.

Caso um erro seja encontrado, acontece um ***shrinking***, que tenta encontrar um caso m√≠nimo que quebre o teste, sendo mais f√°cil de encontrar a raz√£o do problema que levou seu c√≥digo a estar errado. Por exemplo, pode ser que a lista `[1, 1, 1, 0]` n√£o seja ordenada como o esperado. Com o *shrinking*, podemos descobrir que o menor caso de lista que d√™ o erro, por exemplo, seja `[1, 0]`. E assim, gra√ßas ao teste baseado em propriedades, achamos um erro no nosso c√≥digo com um caso que n√£o pensamos e assim podemos melhorar ainda mais nossa l√≥gica.

O Andrew mostrou bem didaticamente como fazer v√°rios testes baseados em propriedades com exemplo "reais".

![Andrew Rosa - Mantendo a Sanidade Testando Estado.](./andrew.jpg)

Para ele e sua equipe, o que foi legal √© que como muitos testes s√£o gerados, v√°rios *edge cases* foram encontrados sem que eles tenham que ficar pensando sobre encontr√°-los manualmente. Por√©m, como s√£o muitos testes a serem rodados, eles demoram! √â necess√°rio saber qual o **retorno de investimento** daquele teste, voc√™ n√£o precisa fazer por exemplo para um *CRUD*, mas pode pegar partes sens√≠veis de seu sistema e submet√™-las a testes baseados em propriedades.

**Nota:** Infelizmente, at√© o momento, os slides da talk ainda n√£o foram postados. Atualizarei o post caso sejam publicados.

## Stand-Up - Em busca do elixir do desenvolvimento - [Rodrigo "pokemaobr" Cardoso](https://twitter.com/pokemaobr)

O grande pokemaobr fez um stand-up na hora do intervalo, levantando risadas da plateia com piadas sobre Elixir e programa√ß√£o em geral.

![Em busca do elixir do desenvolvimento - Pokemaobr](./pokemao.jpg)

## Livestream de Elixir para aumentar a comunidade - [Philip Sampaio](https://twitter.com/philipsampaio)

Na volta do intervalo, agora na trilha iniciante, temos o Philip falando sobre *Live Streaming*. Mas, o que √© *Live Streaming*? Basicamente √© uma transmiss√£o ao vivo de nossas atividades. Geralmente, pensamos em jogos quando falamos sobre live streaming e provavelmente 98% dos streams s√£o de fato sobre jogos. √â fascinante pensar que assistir outros jogadores, ao vivo, √© legal, que existe um p√∫blico bem grande pra isso. E tamb√©m poder interagir via chat, √© algo diferente.

No entanto, algumas pessoas como a [Suz Hinton](https://www.twitch.tv/noopkat) fazem streaming de c√≥digo e utilizam o a plataforma [Twitch](https://www.twitch.tv/) para isso. Ela fala sobre JavaScript/Node.js, bem como Open Source, acessibilidade e IoT. Ela consegue explicar um tema complicado pra algu√©m ao vivo, prestar aten√ß√£o no chat e elaborar um racioc√≠nio complexo ao mesmo tempo - e isso fascinou o Philip.

No final de 2018, o Jos√© Valim - criador do Elixir - come√ßou a fazer o mesmo! Eventualmente, ele fazia lives mostrando como resolver problemas do [Advent of Code](https://adventofcode.com/) e foi bem legal para mostrar como resolver com Elixir alguns desses problemas. Pro Philip isso foi incr√≠vel pois ele tinha muita curiosidade em saber como o pessoal do Open Source *codava* - e descobriu que n√£o era t√£o diferente assim üòâ. A ideia veio do irm√£o do Valim, professor que achava que isso poderia ajudar a comunidade.

O live streaming ajuda a entender o fluxo de trabalho da outra pessoa, a pegar alguns truques que aquela pessoa faz... √â muito √∫til para aprender uma nova tecnologia, ent√£o √© √≥timo poder contar com esse tipo de conte√∫do para o Elixir. Para os _streamers_ em si tamb√©m existem vantagens, pois os ajudam a se comunicar de forma mais eficaz, aprendem a dividir a aten√ß√£o entre o stream e a plateia e tamb√©m podem resolver problemas em conjunto com outras pessoas.

### E por que voc√™ deveria fazer ou participar das *lives*? 
Um dos medos do Philip era: "e se n√£o aparecesse ningu√©m?". Ele percebeu que **divulgar** nas redes sociais era de grande ajuda e o importante √© ajudar pelo menos uma pessoa. "E se eu travasse ou errasse na frente das pessoas?", voc√™ pode se perguntar. Ele diz que acontece e que √© normal, o dia-a-dia da programa√ß√£o √© assim.

Com *live streams* voc√™ vai ajudar a comunidade a crescer, vai melhorar muito suas habilidades e tamb√©m vai se divertir.

O Philip come√ßou com a ideia de dedicar tempo √† biblioteca [Floki](https://github.com/philss/floki) que ele criou, um *parser* de `HTML` feito em Elixir. Mas ele tamb√©m fala sobre outros assuntos como [Live View](https://github.com/phoenixframework/phoenix_live_view), [Ecto](https://github.com/elixir-ecto/ecto) e Elixir b√°sico.

### Como come√ßar?
Ele recomenda utilizar o software [OBS Studio](https://obsproject.com/) para fazer a transmiss√£o.
O OBS faz o stream da tela, possibilita configurar Cenas Ricas, disponibiliza v√°rias configura√ß√µes para microfone/c√¢mera e √© totalmente Open Source!

![Philip, Philip e Philip - Configurando o OBS Studio.](./philip.jpg)

Caso voc√™ n√£o tenha c√¢mera, voc√™ pode usar seu celular e configurar para usar como uma webcam.

O Philip d√° algumas recomenda√ß√µes para quem est√° a fim de come√ßar: experimentar algumas configura√ß√µes do OBS, procurar tutoriais no youtube. Antes das lives, fa√ßa uma agenda de t√≥picos a serem falados; fa√ßa a configura√ß√£o de tudo com anteced√™ncia; desabilite as notifica√ß√µes do sistema operacional; tenha cuidado com o hist√≥rico de comandos do seu terminal; tenha cuidado com segredos em geral e por √∫ltimo, converse com as pessoas do chat - interagir √© o mais legal das lives.

Ele mostrou tamb√©m algumas pessoas que est√£o fazendo streaming de c√≥digo. O [MarcoBrunoBR](https://www.twitch.tv/marcobrunobr) √© provavelmente o mais famoso e fala sobre JavaScript, frontend e React. O [Ulisses Almeida](https://www.twitch.tv/anizark)  fala sobre Elixir, programa√ß√£o funcional e exerc√≠cios de seu livro [Learn Functional Programming with Elixir](https://pragprog.com/book/cdc-elixir/learn-functional-programming-with-elixir). J√° a [JessiTRONica](https://www.twitch.tv/jessitronica)  faz lives sobre Ruby, AWS, Pair Programming, entre outras coisas. Tamb√©m tem o [Jos√© Valim](https://www.twitch.tv/josevalim), que j√° citamos.

Como conclus√£o, o Philip diz que acredita que *live streamings* podem ser artefatos muito poderosos para fazer a comunidade Elixir crescer no Brasil.

Confira os slides no [SpeakerDeck](https://speakerdeck.com/philss/streaming-de-codigo-elixir-para-aumentar-a-comunidade).

## Mesa redonda com streamers de Elixir - [Philip Sampaio](https://twitter.com/philipsampaio), [Ulisses Almeida](https://twitter.com/ulissesalmeida) e [Geovane Fedrecheski](https://twitter.com/geonnave)

![Mesa redonda com os streamers. Da esquerda para direita: Geovane, Philip e Ulisses.](./mesa_redonda_streamers.jpg)

Na conversa desse mesa redonda, consegui pegar algumas dicas, que compartilho com voc√™s. Eles ressaltam a diferen√ßa v√≠deo e streaming: stream √© mais simples, n√£o necessita de edi√ß√£o e se errar est√° ok, pode ser uma forma de come√ßar. A ideia para come√ßar √© pegar um assunto bem basic√£o e tentar ir evoluindo ao longo do tempo, percebendo acertos e erros. O **tempo de live** que eles julgam bom √© **entre uma hora e uma hora e meia**. J√° para **v√≠deos**, o que funciona s√£o **coisas curtas**, at√© **uns cinco minutos** cada. Eles comentaram sobre a possibilidade de se usar o YouTube tamb√©m como plataforma, ao inv√©s do Twitch, que √© algo que o Geovane faz.

Outra dica que deram √© que o Jos√© Valim tem um [curso legal na Pluralsight](https://www.pluralsight.com/courses/meet-elixir) (em ingl√™s) sobre Elixir, Phoenix.

Eles compartilharam a experi√™ncia de cada um e responderam diversas perguntas da plateia. Eu tive algumas d√∫vidas tamb√©m, ent√£o foi dif√≠cil conseguir escrever mais. De qualquer forma, foi uma mesa redonda bem legal :)

## Lightning Talks

A organiza√ß√£o deu espa√ßo para algumas talks rel√¢mpago - de cinco minutos. Houve uma vota√ß√£ozinha e v√°rias pessoas se apresentaram pra falar sobre diversos temas. 

O [Felipe Orlando](https://br.linkedin.com/in/felipeorlando) come√ßou falando sobre como √© o processo seletivo dentro das empresas e como conseguir um trampo em Elixir. Mas, o que todo dev elixir tem que ter?

Primeiro, descubra qual √© a empresa do seus sonhos, entre na p√°gina de vagas e veja quais s√£o os requisitos dessa empresa. Sejam curiosos, pesquisem, estudem, n√£o tenham medo de conhecer coisas novas e nem medo de errar - inclusive nos testes pr√°ticos de empresas. Participe sempre de eventos, √© muito v√°lido pelo networking e pelo aprendizado.

Em termos de conhecimento t√©cnico, procure saber um pouco de estrutura de dados, algoritmos e coloque o estudo em pr√°tica fazendo pequenas aplica√ß√µes em casa, sem medo de dar certo ou errado. *TDD* √© muito importante, √© o que vai garantir que a sua aplica√ß√£o √© confi√°vel. Entender o ecossistema do Elixir √© importante, fazer testes, ter *CI*, ter *linters*, ter uma boa documenta√ß√£o do c√≥digo feito. *Clean code* √© muito importante, fazer c√≥digo f√°cil de entender por outras pessoas. Ingl√™s √© primordial, pois permite que voc√™ consuma conte√∫do na internet e aumente seus conhecimentos. 

E diz tamb√©m que empresa boa √© empresa que responde - se ela n√£o te respondeu, talvez ela n√£o era t√£o boa. Empresa boa tamb√©m valoriza diversidade e inclus√£o.

Honestamente, n√£o consegui acompanhar direito as outras talks rel√¢mpagos, pois acabei tendo a honra de fazer uma talk rel√¢mpago tamb√©m, de √∫ltima hora. Falei sobre o [Exercism](https://exercism.io/), uma plataforma opensource para pr√°tica de c√≥digo e mentoria para todos - um lugar legal pra aprender Elixir e Programa√ß√£o Funcional!

V√°rias comunidades acabaram se apresentando tamb√©m. Elas estiveram presentes gra√ßas a uma iniciativa muito legal de diversidade do evento.

<blockquote class="twitter-tweet" style="margin: 0 auto"><p lang="pt" dir="ltr">No dia da √Åfrica, estamos fazendo hist√≥ria: <a href="https://twitter.com/AfroPython?ref_src=twsrc%5Etfw">@AfroPython</a> , <a href="https://twitter.com/tecnogueto?ref_src=twsrc%5Etfw">@tecnogueto</a> , <a href="https://twitter.com/perifacode?ref_src=twsrc%5Etfw">@perifacode</a> e <a href="https://twitter.com/afrotechbr?ref_src=twsrc%5Etfw">@afrotechbr</a> participando de grandes eventos. Tecnologia e Diversidade caminham lado a lado<br>Pessoas, s√£o o CENTRO.<br>N√£o √© inclus√£o. √â pertencimento. Esses espa√ßos tamb√©m s√£o nossos. <a href="https://twitter.com/hashtag/Ubuntu?src=hash&amp;ref_src=twsrc%5Etfw">#Ubuntu</a> ‚úäüèø <a href="https://t.co/mMMp5WYcRo">pic.twitter.com/mMMp5WYcRo</a></p>&mdash; AfrotechBR (@afrotechbr) <a href="https://twitter.com/afrotechbr/status/1132366765407854593?ref_src=twsrc%5Etfw">May 25, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

## BEAM architecture handbook - [Andrea Leopardi](https://twitter.com/whatyouhide)

Para fechar o evento tivemos o keynote do Andrea, um dos *core commiters* do Elixir j√° h√° tr√™s anos. Ele usa Elixir no trabalho h√° um ano. Nessa talk, ele quer dar bastante dicas para quando voc√™ for fazer sua aplica√ß√£o em Elixir e sobre como funciona a BEAM. Come√ßando a partir de um √∫nico n√≥ e crescendo para v√°rios. Essa talk tamb√©m se aplica a Erlang, ele diz.

### Arquitetura de um √∫nico n√≥

Ele come√ßa com a menor unidade de computa√ß√£o: um processo. √â uma unidade de isolamento e concorr√™ncia (n√£o unidades de separa√ß√£o de c√≥digo). Por exemplo, um "distribuidor de TCP" que distribui processos para "conex√µes TCP". Esse √© um bom caso de uso para processos. Caso uma conex√£o caia, ela est√° isolada e os outras continuam.

![Um "distribuidor de TCP" utilizando processos. Quando uma conex√£o cai, as outras continuam.](./tcp_acceptor.jpg)

Em outro exemplo, voc√™ tem sua conex√£o e um "connection handler", que se conecta a sua sess√£o. Como ele se relaciona com a sua sess√£o? Ela √© s√≥ um punhado de dados e talvez n√£o devesse estar em um processo separado. Ela poderia ser apenas uma "data structure" dentro do *connection handler*. Ele ressalta que o problema de salvar estado dentro de processos √©:

> **Qualquer** processo seu ir√° *morrer* em **qualquer** dado momento e **todo** o estado deles ser√° *perdido*.

Fa√ßa `flush` do estado do processo constantemente, fa√ßa o estado ser recalcul√°vel (sendo praticamente um cache do estado de verdade ou do c√°lculo dele) e mantenha isso em mente, que os processos v√£o morrer.

Evite **impor** arquitetura de processos. 

Separe o estado da estrutura de dados:
```none
                        /-> process
connection data struct----> gen_stage
					    \-> get_statem (machines)
```

Outra dica √© prestar aten√ß√£o √† **MailBox** dos processos, pra n√£o ficar sem mem√≥ria. No exemplo de consumo de mensagens abaixo, √© poss√≠vel cair facilmente nesse problema, pois alguns tipos de mensagens n√£o s√£o consumidas e v√£o parar na **MailBox**. √â algo para se ter em mente.

```elixir
receive do
    :some_message ->
       # ...
    :other_message ->
       # ...
```

Uma forma de lidar com isso √© consumindo mensagens desconhecidas, adicionando logs para podermos saber disso e retornando o pr√≥prio estado.

Guia de uso de **√Årvores de Supervis√£o**:

# ![Andrea e o <strong>Whiteboard Design</strong> das √°rvores de supervis√£o.](./andrea.jpg)

- **Whiteboard Design**: desenhe a √°rvore de supervis√£o num quadro branco para que voc√™ tenha certeza do que est√° acontecendo na aplica√ß√£o.
- **Estrat√©gias**: `one_for_one`, `one_for_all`, `rest_for_one`. Monte √°rvores de supervis√£o aninhadas, utilize-se disso. por exemplo, uma √°rvore de supervis√£o que tem como filhos, tanto o `cache` como tr√™s `workers`. Nenhuma das estrat√©gias funciona bem nesse caso, pois a eventual falha de um desses filhos vai reiniciar coisas de forma errada. Para resolver, o ideal √© ter um supervisor dos tr√™s `workers`, ficando com o `cache` como irm√£o. Assim, voc√™ pode ter uma estrat√©gia para o supervisor principal (`rest_for_one`) e outra para o supervisor de `workers` (`one_for_one`). Todos os processos deveriam ser supervisionados. Sempre d√™ nome para os seus supervisores, para ficar mais f√°cil de debugar em sistemas em produ√ß√£o.
- **Teste de √°rvores de supervis√£o**: uma forma de fazer isso √© com *Chaos Monkey*. O reposit√≥rio [ferd/sups](https://github.com/ferd/sups) ajuda fazendo **property based testing** (como citado na talk do Andrew Rosa) para montar um modelo da sua √°rvore de supervis√£o.

`Connection Handling` - trabalhamos com servi√ßos externos, fora da nossa rede. Geralmente utilizamos processos para lidarmos com isso. Por√©m, e se a conex√£o entre esse processo e o servi√ßo externo cair, o que fazemos?

```none
Seu App ---> Redis Connection -X-> Redis (de verdade)
                              /\ falha de rede, o que fazer?
```

Segundo o Andrea, podemos colocar um *Connection Manager*, que √© respons√°vel por lidar com a l√≥gica de reconex√£o (n√£o deveria ser, por exemplo, a responsabilidade de um supervisor). Em algum ponto sua conex√£o vai cair e voc√™ deve conceber a aplica√ß√£o com isso em mente, se preparando para os poss√≠veis erros. √â raro que voc√™ precise de conex√µes externas o tempo inteiro para sua aplica√ß√£o funcionar, ent√£o podemos usar a abordagem de estar indispon√≠vel por um tempo onde realmente utilizamos.

Tente se reconectar a servi√ßos externos, mas n√£o a cada X segundos ou instantaneamente. Use uma estrat√©gia "backoff", que tenta em tempo exponencial e tamb√©m um pouco randomizado (um pouco de tempo a mais ou a menos em cada tentativa).

**Processos gargalo** s√£o processos que todo o seu sistema depende e que atrasam tudo caso fiquem lentos. Por exemplo, chamadas bloqueantes para o Cache. Ent√£o seu cache vai ser um gargalo. Uma tabela `ETS` pode ajudar a resolver esse problema.

![Tabela ETS para lidar com processos gargalo.](./ets_table.jpg)

`Pools` de conex√µes tamb√©m podem ser uma solu√ß√£o para esses gargalos, onde atrav√©s de uma rota√ß√£o, voc√™ acessa os servi√ßos.

**Error Handling**: lide com todos os erros **esperados**. Se algum erro pode acontecer, ele com certeza vai. O Andrea comenta que odeia o termo "Let it crash" que √© bastante falado, porque talvez n√£o √© entendido como deveria ser entendido. Ele diz que voc√™ deve tratar os erros e n√£o usar essa frase como desculpa para lidar com os mesmos. D√™ `crash` apenas em erros inesperados ou irrecuper√°veis.

### Arquitetura de muitos n√≥s

Frequentemente, o Andrea ouve que o *BEAM* "resolve sistemas distribuidos" e a rea√ß√£o dele √© **N√ÉO**! Para ele, o BEAM √© apenas um bom conjunto de ferramentas! Como por exemplo, `send/2`, `Process.monitor/1`, `Node.monitor/2` e o registro de processos `:global`. Ele at√© brinca:

> to beam or not to beam

Por exemplo para *Data Storage*, devo usar *RDBMS* (como o *Postgres*, *MySQL*) ou uma solu√ß√£o *BEAM* (como o *Riak*)?
Para tomar decis√µes assim, pense em interoperabilidade, recursos relacionais e na an√°lise de dados. J√° para um banco *key/value*, usamos *Redis* ou *ETS/Mnesia*? Replica√ß√£o √© dif√≠cil. A abordagem Phoenix por exemplo √© a de usar mais de uma solu√ß√£o, como *pg2* + *Redis pub/sub*.

O Andrea ainda explicou sobre **application failovers**: se a minha aplica√ß√£o falhar, outra aplica√ß√£o de p√©, que estava parada, assume. E sobre **hot-code upgrades** diz que n√£o s√£o t√£o utilizados e que conflitam com a abordagem de cont√™ineres Docker. Ele diz para nos questionarmos: "Eu realmente preciso disso?" - e que na opini√£o dele, geralmente n√£o precisamos.
Com *websockets* √© mais complicado, mas com *requests* normais √© mais tranquilo.

Existem 3 tipos de **requests**: os que ocorrem **no m√°ximo uma vez**, os que ocorrem **pelo menos uma vez** e os que ocorrem **exatamente uma vez**.
Para as requisi√ß√µes que podemos fazer at√© **no m√°ximo uma vez** n√£o tem muito o que fazer.
√â importante ter [idempot√™ncia](https://pt.wikipedia.org/wiki/Idempot%C3%AAncia) para *requests* que podem acontecer pelo menos uma vez. Se chamar mais de uma vez, voc√™ lida com isso (por exemplo salvar no banco de dados mais de uma vez). **Exatamente uma vez** √© o tipo mais caro de *requests*, porque voc√™ tem que garantir que eles v√£o sempre funcionar (por exemplo transa√ß√µes).

### Conclus√µes

> "Use a ferramenta certa para o trabalho"
>
> Capit√£o √ìbvio

N√£o tente usar o *BEAM* pra tudo. Voc√™ pode usar muitas outras ferramentas e tecnologias mas, se mesmo assim decidir usar, tente seguir as dicas dessa talk. Aprenda sobre **Sistemas distribu√≠dos**. A arquitetura BEAM √© **boa**, leve isso com voc√™.

### Recursos
- [Designing for scalability with Erlang/OTP](http://shop.oreilly.com/product/0636920024149.do)
- [https://ferd.ca](https://ferd.ca/)
- [Distributed system for fun and profit](http://book.mixu.net/distsys/index.html)

Confira os slides (lindos demais, desenhados a m√£o!) da talk do Andrea no [SpeakerDeck](https://speakerdeck.com/whatyouhide/beam-architecture-handbook).

## That's all Folks!

Com isso, chegamos ao fim desse evento maravilhoso. Como j√° comentei antes, achei incr√≠vel o evento sob todos os aspectos.
Fica aqui meus parab√©ns √† organiza√ß√£o.

![<a href="https://twitter.com/mjcoffeeholick" rel="nofollow">Alda Rocha</a> e <a href="https://twitter.com/noteu" rel="nofollow">Jo√£o Britto</a> - os organizadores do Evento. Foto por <a href="https://www.behance.net/gallery/81294793/Elixir-Brasil-2019-Maio-2019" rel="nofollow">Gabi Nascimento</a>.](./organizadores.jpg)

Tamb√©m deixo meus parab√©ns para a curadoria de palestrantes do evento e todos os ajudaram de alguma forma. Valeu demais!

<blockquote class="twitter-tweet" style="margin: 0 auto"><p lang="pt" dir="ltr">N√£o temos palavras pra agradecer a todas as pessoas e empresas que ajudaram a <a href="https://twitter.com/hashtag/ElixirBrasil?src=hash&amp;ref_src=twsrc%5Etfw">#ElixirBrasil</a> acontecer &lt;3 Nos vemos em 2020 <a href="https://t.co/GiY6tq9pxm">pic.twitter.com/GiY6tq9pxm</a></p>&mdash; Elixir Brasil (@elixir_brasil) <a href="https://twitter.com/elixir_brasil/status/1132822827009282049?ref_src=twsrc%5Etfw">May 27, 2019</a></blockquote>

Nos vemos em 2020 - quem sabe com uma talk minha tamb√©m? üòâ
